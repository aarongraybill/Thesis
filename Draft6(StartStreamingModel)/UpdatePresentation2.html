<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Group Update Presentation!</title>
    <meta charset="utf-8" />
    <meta name="author" content="Aaron Graybill" />
    <meta name="date" content="2021-11-18" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Group Update Presentation!
### Aaron Graybill
### 11/18/2021

---







class: inverse, center, middle

# Motivation &amp; Guiding Question

---

## Catching everyone up to speed:

1.  Started with modeling the fine art market and gaining exposure there

2.  Wasn't loving how the model was shaping up

3.  Pivoting to modeling how new artists can "make it" on streaming platforms with strong algorithmic content matching

---

## More on motivation:

-   Consumers don't really face a budget constraint anymore for certain art (think Spotify)

    -   So consumers simply allocate their finite time towards a bundle of artists
    -   This is a fun and pretty new idea economics!

-   Artists generate revneue from the number of streams they get

    -   Streams aren't a function of quality or amount (at least directly)
    -   Artists are beholden to the streaming platform's algorithm to match them with new consumers

-   Platforms make money from ad revenue and premium subscriptions
---

## The Literature, Briefly
- Optimal royalty rates for streaming platform (Hiller &amp; Walter, 2017)
- Crowding out music piracy by streaming platform (Thomes, 2013)
- *Long tail of music production* (Aguiar &amp; Waldfogel, 2018)
- My niche:
  - The artist's problem
  - Impact of algorithm

---
## Guiding Question:

### ***How should a new artist optimally tradeoff between more releases and higher quality under uncertainty about the size of their audience next period?***

---
class: inverse, center, middle

# Big Picture on the Model

---
## Basic Structure
1. Abstract away from streaming platform's decisions
2. Producer produces `\(n\)` pieces of art at quality `\(q\)` (tradeoff)
3. In the eyes of the producer, the algorithm takes the observable variables ( `\(n\)`, `\(q\)`,last period's audience) adds some random noise, and shows it to a proportion of the audience
4. Consumers, once exposed to an artist, consume some amount which reinforces the algorithm for next period

---

## Difficulties Solving the Model

- Time interdependence
- Picking reasonable functional forms that mirror real life properties
- Tractably introducing consumer preferences (especially over time)
- Where continuous variables are necessary and when binary choice is acceptable
- **Defining what the artist has control over**
  - Sufficient choice set without making solving impossible

---

## Next Steps

- Keep reading (penetration curve literature)
- Write down a baseline model for methodology assignment
  - Solve said model
  - Interpret FOCs
- Poke holes in my model and make an improved model

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
